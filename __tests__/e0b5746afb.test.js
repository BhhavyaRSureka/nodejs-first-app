// ********RoostGPT********
/*
Test generated by RoostGPT for test NodeMochaTest using AI Type Open AI and AI Model gpt-4-1106-preview


ROOST_TEST_HASH=e40d9c5245

*/

// ********RoostGPT********
// Import statements
import express from "express";
import path from "path";
import mongoose from "mongoose";
import cookieParser from "cookie-parser";
import jwt from "jsonwebtoken";
import bcrypt from "bcrypt";
import request from "supertest"; // You'll need to install supertest to test Express routes
import User from "../index"; // Assuming the User model is exported from the index.js file

// Connect to a new in-memory database before running any tests.
beforeAll(async () => {
  await mongoose.connect(global.__MONGO_URI__, { useNewUrlParser: true, useUnifiedTopology: true }, (err) => {
    if (err) {
      console.error(err);
      process.exit(1);
    }
  });
});

// Clear all test data after every test.
afterEach(async () => await User.deleteMany());

// Remove and close the db and server.
afterAll(async () => await mongoose.connection.close());

// Test suite for Register endpoint
describe('/POST register', () => {
  test('It should register a new user and redirect to root', async () => {
    await request(app)
      .post('/register')
      .send({ name: 'Test User', email: 'test@example.com', password: 'password' })
      .then((response) => {
        expect(response.headers.location).toBe('/');
        expect(response.status).toBe(302);
      });
  });

  test('It should not register a user with a taken email and redirect to login', async () => {
    const user = new User({
      name: 'Existing User',
      email: 'existing@example.com',
      password: 'password'
    });
    await user.save();

    await request(app)
      .post('/register')
      .send({ name: 'New User', email: 'existing@example.com', password: 'newpassword' })
      .then((response) => {
        expect(response.headers.location).toBe('/login');
        expect(response.status).toBe(302);
      });
  });

  test('It should store user with a hashed password', async () => {
    await request(app)
      .post('/register')
      .send({ name: 'Hash Test User', email: 'hash@example.com', password: 'password' });

    const user = await User.findOne({ email: 'hash@example.com' });
    const passwordMatches = await bcrypt.compare('password', user.password);
    expect(passwordMatches).toBe(true);
  });

  test('It should provide a cookie with a jwt', async () => {
    const response = await request(app)
      .post('/register')
      .send({ name: 'Cookie User', email: 'cookie@example.com', password: 'password' });

    expect(response.headers['set-cookie'][0]).toMatch(/token=/);
  });
});

// Set up and configure the app and necessary middleware for testing
const app = express();
app.use(express.json());
app.use(express.urlencoded({ extended: false }));
app.use(cookieParser());
app.post("/register", async (req, res) => {
  const {
    name,
    email,
    password
  } = req.body;
  let user = await User.findOne({
    email
  });
  if (user) {
    return res.redirect("/login");
  }
  const hashedPassword = await bcrypt.hash(password, 10);
  user = await User.create({
    name,
    email,
    password: hashedPassword
  });
  const token = jwt.sign({
    _id: user._id
  }, "sdjasdbajsdbjasd");
  res.cookie("token", token, {
    httpOnly: true,
    expires: new Date(Date.now() + 60 * 1000)
  });
  res.redirect("/");
});

