// ********RoostGPT********
/*
Test generated by RoostGPT for test NodeMochaTest using AI Type Open AI and AI Model gpt-4-1106-preview


ROOST_TEST_HASH=e40d9c5245

*/

// ********RoostGPT********
const express = require("express");
const path = require("path");
const mongoose = require("mongoose");
const cookieParser = require("cookie-parser");
const jwt = require("jsonwebtoken");
const bcrypt = require("bcrypt");
const User = require("../index"); // Adjusted to reflect the correct relative path from the __tests__ directory

const app = express();
app.use(express.json());
app.use(cookieParser());

describe('/register endpoint', () => {
  let server;
  let request;
  const mockUserFindOne = jest.spyOn(User, 'findOne');
  const mockUserCreate = jest.spyOn(User, 'create');
  const mockBcryptHash = jest.spyOn(bcrypt, 'hash');
  const mockJwtSign = jest.spyOn(jwt, 'sign');

  beforeAll(() => {
    server = app.listen(5000);
  });

  beforeEach(() => {
    request = require('supertest');
    mockUserFindOne.mockClear();
    mockUserCreate.mockClear();
    mockBcryptHash.mockClear();
    mockJwtSign.mockClear();
  });

  afterAll((done) => {
    server.close(done);
  });

  test('should redirect to /login if the user already exists', async () => {
    mockUserFindOne.mockResolvedValue(true);
    const response = await request(server).post('/register').send({
      name: 'Jane Doe',
      email: 'jane@example.com',
      password: 'password123'
    });
    expect(response.headers.location).toBe('/login');
    expect(mockUserCreate).not.toHaveBeenCalled();
  });

  test('should create a new user and redirect to / if the user does not exist', async () => {
    mockUserFindOne.mockResolvedValue(null);
    mockUserCreate.mockResolvedValue({ _id: 'userId' });
    mockBcryptHash.mockResolvedValue('hashedPassword');
    mockJwtSign.mockReturnValue('signedJwtToken');

    const response = await request(server).post('/register').send({
      name: 'John Doe',
      email: 'john@example.com',
      password: 'password123'
    });

    expect(mockUserFindOne).toHaveBeenCalledWith({
      email: 'john@example.com'
    });
    expect(mockBcryptHash).toHaveBeenCalledWith('password123', 10);
    expect(mockUserCreate).toHaveBeenCalledWith({
      name: 'John Doe',
      email: 'john@example.com',
      password: 'hashedPassword'
    });
    expect(mockJwtSign).toHaveBeenCalledWith({ _id: 'userId' }, "sdjasdbajsdbjasd");
    expect(response.headers['set-cookie'][0]).toMatch(/^token=signedJwtToken;/);
    expect(response.headers.location).toBe('/');
  });

  test('should handle errors thrown during user creation', async () => {
    mockUserFindOne.mockResolvedValue(null);
    mockUserCreate.mockRejectedValue(new Error('User creation failed'));
    
    const response = await request(server).post('/register').send({
      name: 'John Doe',
      email: 'john@example.com',
      password: 'password123'
    });

    expect(response.status).toBe(500);
  });
});

