// ********RoostGPT********
/*
Test generated by RoostGPT for test NodeMochaTest using AI Type Open AI and AI Model gpt-4-1106-preview


ROOST_TEST_HASH=39ab36566c

*/

// ********RoostGPT********
const express = require("express");
const path = require("path");
const mongoose = require("mongoose");
const cookieParser = require("cookie-parser");
const jwt = require("jsonwebtoken");
const bcrypt = require("bcrypt");
const { isAuthenticated } = require("../index"); // Assuming this follows the provided project structure

// Mocking required modules
jest.mock("mongoose");
jest.mock("jsonwebtoken");
jest.mock("bcrypt");

// Setup Express app and middleware
const app = express();
app.use(cookieParser());

describe("Authentication Middleware - isAuthenticated", () => {

  let mockReq, mockRes, mockNext;

  beforeAll(() => {
    // Connect to a mock database before running all tests
    mongoose.connect();
  });

  afterAll(() => {
    // Disconnect from the mock database after all tests are finished
    mongoose.disconnect();
  });

  beforeEach(() => {
    // Mock express request and response objects before each test
    mockReq = { cookies: {} };
    mockRes = {
      redirect: jest.fn()
    };
    mockNext = jest.fn();
  });

  afterEach(() => {
    // Clear all mocks after each test to ensure tests are independent
    jest.clearAllMocks();
  });

  test("should call next() if token is valid", async () => {
    const token = "validToken";
    mockReq.cookies.token = token;
    const decodedToken = { _id: "validUserId" };

    jwt.verify.mockReturnValue(decodedToken);
    mongoose.Model.findById = jest.fn().mockResolvedValue({
      _id: "validUserId",
      username: "testUser"
    });

    await isAuthenticated(mockReq, mockRes, mockNext);

    expect(jwt.verify).toHaveBeenCalledWith(token, expect.any(String));
    expect(mongoose.Model.findById).toHaveBeenCalledWith(decodedToken._id);
    expect(mockReq.user).toBeDefined();
    expect(mockRes.redirect).not.toHaveBeenCalled();
    expect(mockNext).toHaveBeenCalled();
  });

  test("should redirect to login if token is missing", async () => {
    await isAuthenticated(mockReq, mockRes, mockNext);

    expect(mockRes.redirect).toHaveBeenCalledWith("/login");
    expect(mockNext).not.toHaveBeenCalled();
  });

  test("should redirect to login if token is invalid", async () => {
    const invalidToken = "invalidToken";
    mockReq.cookies.token = invalidToken;

    jwt.verify.mockImplementation(() => {
      throw new Error();
    });
    
    await isAuthenticated(mockReq, mockRes, mockNext);

    expect(jwt.verify).toHaveBeenCalledWith(invalidToken, expect.any(String));
    expect(mockRes.redirect).toHaveBeenCalledWith("/login");
    expect(mockNext).not.toHaveBeenCalled();
  });

  // Add more test cases if necessary...
});

